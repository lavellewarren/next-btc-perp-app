// @ts-ignore
import { getMint, getAssociatedTokenAddress, createAssociatedTokenAccountInstruction, createMint, TOKEN_PROGRAM_ID, getAccount } from '@solana/spl-token';
import * as anchor from '@project-serum/anchor';
import { Keypair, PublicKey, sendAndConfirmTransaction, Signer, SystemProgram, SYSVAR_RENT_PUBKEY, Transaction } from '@solana/web3.js';
import idl from "./idls/merstab_protocol.json";

export interface VaultMetadata {
    manager: PublicKey,
    mint: PublicKey,
    name: string,
    limit: anchor.BN,
}

/**
 * Wallet interface for objects that can be used to sign provider transactions.
 */
export interface Wallet {
    signTransaction: (transaction: Transaction) => Promise<Transaction>;
    signAllTransactions: (transaction: Transaction[]) => Promise<Transaction[]>;
    publicKey: PublicKey;
}
export class MerstabClient {
    connection: anchor.web3.Connection;
    constructor(public program: anchor.Program, public network: string) {
        this.connection = program.provider.connection;
    }

    static async connect(provider: anchor.AnchorProvider, network: string): Promise<MerstabClient> {
        const program = new anchor.Program(idl as any, MerstabClient.MERSTAB_ID, provider);
        return new MerstabClient(program, network);
    }
    static MERSTAB_ID = new PublicKey("AQPDVpAsDtd8cfXVjrUEKrhchF4cYwST2wyq3tJa82ci");
    static MANGO_OWNER_PDA_SEED = 'mango_owner_pda_seed';
    static STAKED_TOKENS_PDA_SEED = 'staked_token_mint_authority';
    static VAULT_SEED = 'vault-seed';

    async getTokenAccount(quoteMint: PublicKey, wallet: PublicKey) {
        const mUSDCStakerAccount = await getAssociatedTokenAddress(quoteMint, wallet);
        return await getAccount(this.connection, mUSDCStakerAccount);
    }

    async getTokenAccountBalance(tokenAccount: PublicKey) {
        return await this.connection.getTokenAccountBalance(tokenAccount);
    }

    async getMTokenAccount(mTokenMint: PublicKey, wallet: PublicKey) {
        const mUSDCStakerAccount = await getAssociatedTokenAddress(mTokenMint, wallet);
        return await getAccount(this.connection, mUSDCStakerAccount);
    }

    async getVaultDepositAccount(vault: PublicKey) {
        const [account, bump] = await this.deriveVaultAccount(vault);
        return await getAccount(this.connection, account);
    }

    async getVaultData(key: PublicKey): Promise<VaultMetadata> {
        return (await this.program.account.vault.fetch(key)) as unknown as VaultMetadata;
    }

    async deriveMangoAccount(vault: PublicKey) {
        return await PublicKey.findProgramAddress(
            [
                Buffer.from(anchor.utils.bytes.utf8.encode(MerstabClient.MANGO_OWNER_PDA_SEED)),
                vault.toBytes(),
            ],
            this.program.programId
        );
    }

    async deriveVaultAccount(vault: PublicKey) {
        return await PublicKey.findProgramAddress(
            [
                Buffer.from(anchor.utils.bytes.utf8.encode(MerstabClient.VAULT_SEED)),
                vault.toBytes(),
            ],
            this.program.programId
        );
    }

    async deriveMTokenAuthority(vault: PublicKey) {
        return await PublicKey.findProgramAddress(
            [
                Buffer.from(anchor.utils.bytes.utf8.encode(MerstabClient.STAKED_TOKENS_PDA_SEED)),
                vault.toBytes(),
            ],
            this.program.programId
        );
    }

    // node helper function
    async addVault(vaultName: string, wallet: Keypair, limit: number, depositMint: string) {
        const vault = Keypair.generate();
        console.log(`New vault public key ${vault.publicKey.toString()}`);

        const [mangoOwnerPDA, mangoOwnerBump] = await this.deriveMangoAccount(vault.publicKey);
        const [tokenAccountPDA, tokenAccountBump] = await this.deriveVaultAccount(vault.publicKey);

        const stakedMint = await createMint(
            this.connection,
            wallet,
            wallet.publicKey,
            wallet.publicKey,
            6,
            anchor.web3.Keypair.generate(),
            null,
            TOKEN_PROGRAM_ID
        );
        console.log(`Staked token mint: ${stakedMint.toString()}`);

        // generated by me
        const quoteMint = new PublicKey(depositMint);

        this.program.methods
            .addVault(vaultName, new anchor.BN(limit), mangoOwnerBump)
            .accounts({
                vault: vault.publicKey,
                manager: wallet.publicKey,
                tokenAccount: tokenAccountPDA,
                tokenAccountAuthority: mangoOwnerPDA,
                stakedTokenMint: stakedMint,
                payer: wallet.publicKey,
                mint: quoteMint,
                rent: SYSVAR_RENT_PUBKEY,
                tokenProgram: TOKEN_PROGRAM_ID,
                systemProgram: SystemProgram.programId,
            })
            .signers([vault, wallet])
            .rpc()
    }

    async stake(amount: anchor.BN,
        wallet: PublicKey,
        vaultPk: PublicKey,
        depositMint: PublicKey,
        keypair?: Keypair | null,
        sendTransaction?: Function) {
        // get these values from add vault
        const vault = vaultPk;
        console.log(`Vault: ${vault.toString()}`);
        const vaultData: VaultMetadata = await this.getVaultData(vault);
        const merstabUSDCMint = vaultData.mint;
        console.log(merstabUSDCMint.toString());

        // init tx
        const tx = new Transaction();

        const mUSDCStakerAccount = await getAssociatedTokenAddress(merstabUSDCMint, wallet);

        try {
            const merstabTokenAccountInfo = await getAccount(this.connection, mUSDCStakerAccount);
            console.log(`Found token account existing for mint: ${mUSDCStakerAccount.toString()}`);
        } catch (err) {
            console.log(err);
            console.log(`Could not find token account for mint ${merstabUSDCMint.toString()} and wallet ${wallet.toString()}`);
            console.log(`Creating token account ${mUSDCStakerAccount.toString()}`);

            const ataIx = createAssociatedTokenAccountInstruction(
                wallet,
                mUSDCStakerAccount,
                wallet,
                merstabUSDCMint,
            )
            tx.add(ataIx);
        }

        const walletUSDCAccount = await getAssociatedTokenAddress(depositMint, wallet);
        const [tokenAccountPDA, tokenAccountBump] = await this.deriveVaultAccount(vault);
        const [stakedTokenMintPDA, stakedTokenMintBump] = await this.deriveMTokenAuthority(vault);

        try {
            const ix = await this.program.methods
                .stake(amount, tokenAccountBump, stakedTokenMintBump)
                .accounts({
                    vault: vault,
                    vaultTokenAccount: tokenAccountPDA, // vault USDC
                    stakersTokenAccount: walletUSDCAccount, // user USDC
                    stakersAta: mUSDCStakerAccount, // user merUSDC
                    stakedTokenMintAuthority: stakedTokenMintPDA, // should be same as mUSDCMint.mintAuthority
                    staker: wallet,
                    stakedTokenMint: merstabUSDCMint,
                    tokenProgram: TOKEN_PROGRAM_ID,
                })
                .instruction();
            tx.add(ix);

            if (sendTransaction) {
                const signature = await sendTransaction(tx, this.connection);
                console.log(`txhash: ${signature}`);
                await this.connection.confirmTransaction(signature, "processed");
            } else {
                const txId = await sendAndConfirmTransaction(this.connection, tx, [keypair as anchor.web3.Signer]);
                console.log(`txhash: ${txId}`);
                return txId;
            }
        } catch (err) {
            console.log(err);
            throw err;
        }
    }

    async unstake(amount: anchor.BN,
        wallet: PublicKey,
        vaultPk: PublicKey,
        withdrawMint: PublicKey,
        keypair?: Keypair | null,
        sendTransaction?: Function) {
        // get these values from add vault
        const vault = vaultPk;
        const vaultData: VaultMetadata = await this.getVaultData(vault);
        const merstabUSDCMint = vaultData.mint;

        const mUSDCMint = await getMint(this.connection, merstabUSDCMint, null, TOKEN_PROGRAM_ID);
        const mUSDCStakerAccount = await getAssociatedTokenAddress(merstabUSDCMint, wallet);

        try {
            const mUSDCAccountInfo = await getAccount(this.connection, mUSDCStakerAccount);
            console.log(`Found token account existing for mint: ${mUSDCStakerAccount.toString()}`);
        } catch (err) {
            console.log(err);
            console.log(`Could not find token account ${mUSDCStakerAccount.toString()}`);
            throw new Error("Account does not exist");
        }

        const walletUSDCAccount = await getAssociatedTokenAddress(withdrawMint, wallet);
        const [mangoOwnerPDA, mangoOwnerBump] = await this.deriveMangoAccount(vault);
        const [tokenAccountPDA, tokenAccountBump] = await this.deriveVaultAccount(vault);
        const [stakedTokenMintPDA, stakedTokenMintBump] = await this.deriveMTokenAuthority(vault);

        try {
            const ix = await this.program.methods
                .unstake(new anchor.BN(amount), mangoOwnerBump)
                .accounts({
                    vault: vault,
                    vaultTokenAccount: tokenAccountPDA,
                    vaultTokenAuthority: mangoOwnerPDA,
                    stakersTokenAccount: walletUSDCAccount,
                    stakersAta: mUSDCStakerAccount,
                    stakedTokenMintAuthority: stakedTokenMintPDA,
                    staker: wallet,
                    stakedTokenMint: merstabUSDCMint,
                    tokenProgram: TOKEN_PROGRAM_ID,
                })
                .instruction()
            const tx = new Transaction().add(ix);

            if (sendTransaction) {
                const signature = await sendTransaction(tx, this.connection);
                console.log(`txhash: ${signature}`);
                await this.connection.confirmTransaction(signature, "processed");
                return signature.hash;
            } else {
                const txId = await sendAndConfirmTransaction(this.connection, tx, [keypair as anchor.web3.Signer]);
                console.log(`txhash: ${txId}`);
                return txId;
            }
        } catch (err) {
            console.log(err);
            throw err;
        }
    }
}